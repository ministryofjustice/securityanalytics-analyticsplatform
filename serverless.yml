service: ${self:custom.app-name}-${self:custom.plugin-name}

external-gateway: &external-gateway
  restApiId: ${ssm:/${self:custom.app-name}/${opt:stage, '${env:USERNAME}'}/api/public/id, ''}
  restApiRootResourceId: ${ssm:/${self:custom.app-name}/${opt:stage, '${env:USERNAME}'}/api/public/root, ''}
  authorizer:
    type: COGNITO_USER_POOLS
    authorizerId: ${ssm:/${self:custom.app-name}/${opt:stage, '${env:USERNAME}'}/api/public/authorizer, ''}

custom:
  app-name: sec-an
  plugin-name: analytics
  apiGatewayConfigOptions:
    dev: *external-gateway
    prod: *external-gateway
    other:
      restApiId: ""
      restApiRootResourceId: ""
      authorizer: ""
  # If a defined integration exists in apiGatewayConfigOptions e.g. dev or prod
  # then serverless will take that value, if it is undefined it falls back to 'other'
  # which provides no api gateway details and serverless will create a new one for us
  apiGatewayConfig:
    ${self:custom.apiGatewayConfigOptions.${opt:stage, '${env:USERNAME}'}, self:custom.apiGatewayConfigOptions.other}
  output:
    file: .generated/stack.json
  exportEndpoints:
    path: .generated/endpoints.json
  pythonRequirements:
    cacheLocation: ${env:PWD}/.cache
    useDownloadCache: true
    useStaticCache: true
    dockerizePip: non-linux
    # setting this to true breaks the zip
    slim: false
    # Dont use zip, it makes things bigger because the no deploy filtering seems to be ignored
    zip: false
    noDeploy:
      # provided by our layer
      - utils
      # the rest by lambda
      - boto3
      - botocore
      - docutils
      - jmespath
      - python-dateutil
      - s3transfer
      - six
      - pip
      - setuptools

provider:
  name: aws
  runtime: python3.7
  region: ${opt:region, 'eu-west-2'}
  stage: ${opt:stage, '${env:USERNAME}'} # so when developing we keep things independent, can be overridden
  endpointType: REGIONAL # TODO
  # Here if we are on dev (or later qa or prod), then we hook up to the shared gateway
  # other wise we are probably just running integration tests and need to create our own gateway
  apiGateway:
    restApiId: ${self:custom.apiGatewayConfig.restApiId}
    restApiRootResourceId: ${self:custom.apiGatewayConfig.restApiRootResourceId}
# TODO additional efforts are needed to get lambdas to run inside the vpc
#  vpc:
#    securityGroupIds:
#      - TODO
#    subnetIds: ${ssm:/${self:custom.app-name}/${opt:stage, '${env:USERNAME}'}/vpc/subnets/instance}

plugins:
  - serverless-stack-output
  - serverless-python-requirements
  # used for integration testing
  - serverless-plugin-export-endpoints
  # used for testing and local development
  - serverless-offline

package:
  individually: false
  # This negative include is important for performance
  # https://github.com/serverless/serverless/pull/5825
  include:
    - "!./**"
    - "./queue_injestor/**"
  exclude:
    - "**"

functions:
  injestor: ${file(queue_injestor/queue_injestor.yml):function}

resources:
  Resources:
    sampleRole: ${file(queue_injestor/queue_injestor.yml):role}


